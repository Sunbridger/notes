# NodeList具有遍历器接口，可用for of进行遍历

## 对象原型在实例化之后保持不变，直到ECMAScript5都是编程最重要的设定之一 ES6添加了Object.setPrototypeOf()方法来改变任意指定对象的原型，其接受两个参数：需要改变的对象，指定的原型
```
let Person = {
    say(){
        console.log('你好人类')
    }
}
let Anima = {
    say(){
        console.log('你好动物')
    }
}

let a = Object.create(Person);
a.say();  //你好人类

Object.setPrototypeOf(a,Anima);
a.say();  //你好动物
```
### 原理剖析：
对象原型的真实值被存储在内部专用属性[[Prototype]]中，调用es5中的api Object.getPrototypeOf()方法返回存储在其中的值，调用es6中的api Object.setPrototypeOf()方法来改变其中的值。然而这并不是唯一操作[[Prototype]]的方法

### 现状分析：

#### 警告: 通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性, 这种行为在每一个JavaScript引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 obj["双下划线proto双下划线"]= ... 语句上, 它还会影响到所有继承来自该 [[Prototype]] 的对象，如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]。相反, 创建一个新的且可以继承 [[Prototype]] 的对象，推荐使用 Object.create()。
#### 警告: 当Object.prototype.__proto__已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在ECMAScript 2015规范中被标准化为传统功能，以确保Web浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。

Object.prototype 的__proto__属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 null)。
 
使用__proto__是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 现在更推荐使用Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf（尽管如此，设置对象的[[Prototype]]是一个缓慢的操作，如果性能是一个问题，应该避免）。

## {a:function(){}}和{a(){}}的原型区别.二者唯一的区别是，简写方法可以使用super关键字，而普通方法不可以
```
let f = {
    mysay(){
    //Object.getPrototypeOf(this).say.cal(this)
        return super.say()
    }
}
let e = {
    mysay:function(){
        //语法错误
        return super.say()
    }
}
```
## Super的原理剖析：
### Super的所有引用都是通过[[HomeObject]]属性来确定后续的运行过程。第一步是在[[HomeObject]]属性上调用Object.getPrototypeOf()来检索出原型的引用；然后搜寻原型找到同名函数；最后设置this绑定并且调用相应的方法。