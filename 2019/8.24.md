# just-in-time  即时编译
JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。

Java通常通过 javac 将程序源代码编译转换成 Class文件（java 字节码），JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。
很显然，经过解释执行，其执行速度必然会比直接执行机器码慢很多。为了提高执行速度，引入了 JIT 技术。

当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是 JIT 编译器。

# Hot Spot 编译
如果这段代码本身在将来只会被执行一次，那么编译就是在浪费精力。如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能。以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了，直接执行。

为了最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。

运行过程中会被即时编译器编译的“热点代码”有两类：

被多次调用的方法。

被多次调用的循环体。

## 解释器的利弊
解释器启动和执行的更快。你不需要等待整个编译过程完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行了。

正是因为这个原因，解释器看起来更加适合 JavaScript。对于一个 Web 开发人员来讲，能够快速执行代码并看到结果是非常重要的。

这就是为什么最开始的浏览器都是用 JavaScript 解释器的原因。

可是当你运行同样的代码一次以上的时候，解释器的弊处就显现出来了。比如你执行一个循环，那解释器就不得不一次又一次的进行翻译，这是一种效率低下的表现。

## 编译器的利弊
编译器的问题则恰好相反。

它需要花一些时间对整个源代码进行编译，然后生成目标文件才能在机器上执行。对于有循环的代码执行的很快，因为它不需要重复的去翻译每一次循环。

另外一个不同是，编译器可以用更多的时间对代码进行优化，以使的代码执行的更快。而解释器是在 runtime 时进行这一步骤的，这就决定了它不可能在翻译的时候用很多时间进行优化。

# WebAssembly
  WebAssembly是一种新的字节码格式。它的缩写是".wasm"， .wasm 为文件名后缀，是一种新的底层安全的二进制语法。。它被定义为“精简、加载时间短的格式和执行模型”，并且被设计为Web 多编程语言目标文件格式。 这意味着浏览器端的性能会得到极大提升，它也使得我们能够实现一个底层构建模块的集合，例如，强类型和块级作用域。（原文： And it gives us access to a set of low level building blocks, such as a range of types and operations. 这句话我实在不知如何翻译。。。） 不过别搞错了，这并不意味着WebAssmbly是为了取代 JavaScript而生哟~ 就像Bjarne Stroustup说的：“JS会活得很好，因为世界上只有两种类型的语言：一类语言被人们不断的地吐槽，而另一类语言压根儿没人用！”而 Eric Elliott 认为：“最好不要把WebAssembly仅仅当做一门编程语言，实际上它更像是一个编译器。”

>这玩意儿到底好在哪？

你很可能会问：“为啥所有人都在谈论WebAssembly？”这是因为WebAssembly对于JS来说绝对是一个巨大的改进，但我们常常会问自己：“这样，就够了吗？”当然不是.

WebAssembly对于浏览器来说也有着非同一般的意义。 支持WebAssembly的浏览器可以识别二进制格式的文本，它有能力编译比JS文本小得多的二进制包。 这将给web应用带来类似与本地应用的性能体验！这四不四听起来很棒啊？！

如果浏览器不得不解析完整的JS代码，这将会耗去好多时间（特别是在移动平台上），而浏览器对WebAssembly格式的解码速度显然要快得多得多得多：） 下面献上JS作者BE大神的演讲视频地址（油管，需翻墙）： Brendan Eich on JavaScript Taking Both the High and Low Roads - O'Reilly Fluent 2014