# vue-class-component
> ECMAScript / TypeScript decorator for class-style Vue components.
## usage
1.  `methods` 直接作为class的原型方法如下
```
class A {
  // methods 
  say() {
    // ...
  }
}
```
2. `computed` 作为class的访问器属性（只有get）
```
class A {
  // computed 
  get nameFirst() {
    // ...
  }
}
```
3. `data` 直接作为class的内部属性 `
```
export default class App extends Vue {
  // inital data
  nn = 2 // 需要  `babel-plugin-transform-class-properties i`这个包的支持
  msg = undefinde //不是响应式的
  // hook data
  data() {
    return {
      msg: undefined, // 依旧是响应式的
      nn: 2
    }
  }
}
```
ps： 还是使用hook data写法才好
4. `data`, `render` and all Vue lifecycle hooks can be directly declared as class member methods as well
  > 代码同 1 写法
5. For all other options, pass them to the decorator function.
```
import Component from 'vue-class-component'
@Component({
  props: {
    propMessage: String
  },
  watch: {
    name: function(newname, oldname) {
      // 如果 `name` 发生改变，这个函数就会运行
    }
  }
  components: {
    CompA: 'xxx'
  }
})
export default class App extends Vue {}
```
ps:props和watch的写法不止一种 也可以用@prop and @watch decorators 当然 得额外装包`vue-property-decorator` 或者直接使用`vue-property-decorator`的方式

# ⚠️警告写法
1. `this` value in property
If you define an arrow function as a class property and access this in it, it will not work. This is because this is just a proxy object to Vue instance when initializing class properties:

```
@Component
class MyComp extends Vue {
  foo = 123
  false = () => {
    // Does not update the expected property.
    // `this` value is not a Vue instance in fact.
    this.foo = 456
  }
  right () {
    // Correctly update the expected property.
    this.foo = 456
  }
}

```
2. `undefined` will not be reactive(响应式)
代码如例子3

<hr>

# Vue Property Decorator
This library fully depends on `vue-class-component`, so please read its README before using this library

单纯的`vue-class-component` 还不足以来用type 使用`vue-property-decorator`才可以,它是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器
## usage

There are 7 decorators and 1 function (Mixin): 
- @Prop
- @PropSync
- @Watch
- @Emit
- @Provide
- @Inject
- @Model
- @Component (其实vue-property-decorator内部还是provided by vue-class-component，只不过写法是它了)
- @Mixins (其实vue-property-decorator内部还是provided by vue-class-component，只不过写法是它了)



```
import {Vue, Component} from 'vue-property-decorator';
@Component({})
export default class App extends Vue{
    // 这个现在就是hook data了么？`更新：在vue-property-decorator找到说明了 确实全等`
    ValA: string = "hello world"; // 多了个:string 区别props中自带的类型定义String 
    ValB: number = 1;
    
    // props
    @Prop()
    propA: number = 1

    @Prop({ default: 'default value' })
    propB: string

    @Prop([String, Boolean])
    propC: string | boolean

    @Prop({ type: null })
    propD: any
}
```

相当于下面的 (只写props部分了 ，data部分还不太确定 ，vue-class-component官方说hook data的概念了)
`更新：在vue-property-decorator找到说明了 确实全等`
```
data() {
  return {
    ValA: "hello world",
    ValB: 1
  }
},
props: {
    checked: Boolean,
    propA: Number,
    propB: {
      type: String,
      default: 'default value'
    },
    propC: [String, Boolean],
    propD: { type: null }
  }
```



# Problem show
> Property `xxx` has no initializer and is not definitely assigned in the constructor.

#### wtf??

Google如下：
```
//Since you use the latest version of TS, you mention the error.
//Please see the section "Strict Class Initialization(结构初始化)" in the link.

//So, you'll need to do like this below.
@Component
export default class Modal extends Vue {
  @Prop()
  title!: string; // 加上 ！
  // Notice this '!' modifier.
  // This is the "definite assignment assertion(明确的赋值断言)"
}
```
#### 下面说下Strict Class Initialization
```
class C {
    foo: number;
    bar = "hello";
    baz: boolean;
    //  Error! Property 'baz' has no initializer and is not definitely assigned in the constructor.
    constructor() {
        this.foo = 42;
    }
}
```
Keep in mind that `--strictPropertyInitialization` will be turned on along with other `--strict` mode flags, which can impact your project. You can set the `strictPropertyInitialization` setting to `false` in your `tsconfig.json.s compilerOptions`, or `--strictPropertyInitialization false` on the command line to `turn off `this checking.



# 更新vue文档 依赖注入
> 实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：
- 祖先组件不需要知道哪些后代组件使用它提供的属性
- 后代组件不需要知道被注入的属性来自哪里
`然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。`




