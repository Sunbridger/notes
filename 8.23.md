#webpack5
Automatic Node.js polyfills removed
Back in the day, Webpack’s aim was to allow for running most Node.js modules in the browser, but the module landscape changed and many module uses are now written specifically for front-end purposes. Versions <= 4 shipped with polyfills for a good majority of Node.js core modules that are automatically applied once a module uses any core modules.

>过去，Webpack 的目标是允许在浏览器中运行大多数 Node.js 模块，但是模块版本发生了变化，许多模块的使用现在都是专门为前端目的而编写的。 4版本附带了大多数 Node.js 核心模块的 polyfills，一旦模块使用了任何核心模块，这些模块就会自动应用。

This, in turn, added these large polyfills to the final bundle but were generally unnecessary. The attempts in v5 are to automatically stop polyfilling these core modules and focuses on front-end compatible ones.

>反过来，这又将这些大的多边填充添加到最后的捆绑包中，但通常是不必要的。 V5中的尝试是自动停止 polyfilling 这些核心模块，并侧重于前端兼容的模块。

A newly named chunk id algorithm is now enabled by default in development mode that gives chunks (and filenames) human-readable references. A Module ID is determined by its path that’s relative to the context. A Chunk ID is determined by the chunk’s content so you no longer need to use:

>默认情况下，在开发模式中启用了一个新命名的块 id 算法，该算法提供块(以及文件名)可读的引用。 模块 ID 由其相对于上下文的路径确定。 块 ID 是由块的内容决定的，所以你不再需要使用:
`import(/* webpackChunkName: "name" */ "module")`

# window.history
>Window.history是一个只读属性，用来获取History 对象的引用，History 对象提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口。即加载当前页面的标签页窗口或frame窗口的访问历史

以下为History的对象属性方法介绍

1. attr
- History.length
  >只读的，其值为一个整数，标志包括当前页面在内的会话历史中的记录数量，比如我们通常打开一个空白窗口，length为0，再访问一个页面，其length变为1。

- History.scrollRestoration
  >允许web应用在会话历史导航时显式地设置默认滚动复原，其值为auto或manual。

- History.state
  >只读，返回代表会话历史堆栈顶部记录的任意可序列化类型数据值，我们可以以此来区别不同会话历史纪录。
2. methods

- History.back()
  返回会话历史记录中的上一个页面，等价于window.history.go(-1)和点击浏览器的后退按钮。

- History.forward()
  进入会话历史记录中的下一个页面，等价于window.history.go(1)和点击浏览器的前进按钮。

- History.go()
  加载会话历史记录中的某一个页面，通过该页面与当前页面在会话历史中的相对位置定位，如，-1代表当前页面的上一个记录，1代表当前页面的下一个页面。若不传参数或传入0，则会重新加载当前页面；若参数超出当前会话历史纪录数，则不进行操作。

- History pushState()
   >在会话历史堆栈顶部插入一条记录，参数包括，任意可序列化的object对象数据（可选），页面标题（可选），页面URL（非空）。
  目前，Firefox忽略页面标题参数。
  pushState()方法接收三个参数，一个state对象，一个页面标题，一个URL:
1. 状态对象：
存储新添会话历史记录的状态信息对象，每次访问该条会话时，都会触发popstate事件，并且事件回调函数会接收一个参数，值为该事件对象的复制副本；
状态对象可以是任何可序列化的数据，浏览器将状态对象存储在用户的磁盘以便用户再次重启浏览器时能恢复数据；
一个状态对象序列化后的最大长度是640K，如果传递数据过大，则会抛出异常。
2. 页面标题：
目前 ，该参数值会被忽略，暂不被使用，可以传入空字符串。
3. 页面URL：
此参数声明新添会话记录的入口URL；
在调用pushState()方法后，浏览器不会加载URL指向的页面（在重启浏览器后或许会加载新页面 ），我们可以在popstate事件回调中处理页面是否加载；
此URL必须与当前页面URL同源,，否则会抛异常；其值可以是绝对地址，也可以是相对地址，相对地址会被基于当前页面URL解析 得到绝对地址；若其值为空，则默认是当前页面URL。

- History.replaceState()
   更新会话历史堆栈顶部记录信息，包括特定的任意可序列化的object对象数据（可选），页面标题（可选），页面URL。 同上


`值得注意的是，无论是replaceState()方法还是pushState()方法，其更新或添加会话历史记录后，改变的只是浏览器关于当前页面的标题和URL的记录情况，并不会刷新或改变页面展示。`

window.onpopstate事件支持我们对pushState replaceState操作进行监听。


# 前端数据模型
1. 何时使用interface进行数据模型定义？

interface定义数据应该有的结构，在编程时方便使用。如果interface用于定义数据模型，大部分情况下，只定义模型具备的属性。所以，对于仅仅用于展示的数据模型，不涉及逻辑加工，我们采用interface。

使用interface也有一定的好处，就是它只是在编译阶段帮助编译器识别数值应该具有的数据结构。编译完成之后，interface定义的内容将不再存在，不会占用内存。所以，如果仅仅是直接展示数据，我觉得使用interface去定义数据模型。

2. 何时使用class定义数据模型？

>如果选择class定义数据模型，那么这种数据模型应该拥有比较复杂的处理逻辑。

举个简单的例子，我们希望获取属性值的时候进行一些逻辑加工，那么使用get方法再好不过。如果这是个复杂的模型，提供了很多方法来描述模型的一些行为，那也只能使用class来进行定义了。