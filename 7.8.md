# Typescript 泛型部分
```
function loggingIdentity<T>(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
```
##### 泛型函数loggingIdentity，接收类型参数T和参数arg(它是个元素类型是T的数组)，函数本身并返回元素类型是T的数组。

## 第一个泛型接口(对函数的输入输出的定义)
```
interface GenericIdentityFn {
    <T>(arg: T): T;
}
```
为了知道使用的具体是哪个泛型类型（比如： Dictionary<string>而不只是Dictionary）
```
interface GenericIdentityFn<T> {
    (arg: T): T;
}
```
把非泛型函数签名作为泛型类型一部分。 当我们使用 GenericIdentityFn的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。

### 应用场景：
后端同学A写好了接口地址，负责对应查看接口文档的前端小伙伴B将后端需要的参数，以及返回的类型啥的都确定好，编写此接口地址的函数接口以便给那些不爱看接口文档（或者权限不足）的小伙伴D调用，此时如下：

A给出的接口地址是 172.168.1.1/sunbridger/getData
<br>
B查看文档知道其需要的参数为id:number,type:string这些参数，并且返回一个{name:string,age:number,likes:String[]}这样的结果，于是B编写了这个全局的接口函数
```
interface getDataPra{
    id:number;
    type:string;
}
interface outData{
    name:string;
    age:number;
    likes:String[];
}
interface FanInter22<t,f>{
    (msg:t):f
}
const getDataFn:FanInter22<getDataPra,outData>=(arg:getDataPra)=>{
    let data:outData;
    data = {
        name:'xxx',
        age:12,
        likes:['xxx','aaa']
    } // 这是假设数据库查询返回
    return data;
}

```




 