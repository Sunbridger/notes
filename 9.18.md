# 什么场景下会发生服务器主动关闭连接？

服务器关机、重启、进程关闭、重启
>释放连接、关闭连接、其实是一回事。采用的手段是发送“FIN”状态位，这个动作在中文的翻译里，经常会翻译成“挥手”。这个场景就是服务器迫于关机指令，主动发起的挥手动作。
所谓优雅，就是看起来不是那么突然，有绅士风度，给客户端足够的响应时间发出自己的挥手动作“FIN”。由于服务器主动发起关闭连接，客户端无需等待就进入“Closed”状态，客户端释放内存与使用的端口。

 
按照TCP状态机流程图，谁主动关闭TCP连接，谁需要等待2倍的 MSL（Maximum Segment Life ）时间，这个等待时间对应的状态为“Time_Wait”。操作系统的MSL时间从30-120秒不等，那么等待时间也不过60-240秒，这点等待时间还算能够忍受。


# 缓存穿透
缓存穿透是指查询一个一定不存在的数据，因为缓存中也无该数据的信息，则会直接去数据库层进行查询，从系统层面来看像是穿透了缓存层直接达到db，从而称为缓存穿透，没有了缓存层的保护，这种查询一定不存在的数据对系统来说可能是一种危险，如果有人恶意用这种一定不存在的数据来频繁请求系统，不，准确的说是攻击系统，请求都会到达数据库层导致db瘫痪从而引起系统故障。


1. bloom filter：类似于哈希表的一种算法，用所有可能的查询条件生成一个bitmap，在进行数据库查询之前会使用这个bitmap进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。guava中有实现BloomFilter算法。


2. 空值缓存：一种比较简单的解决办法，在第一次查询完不存在的数据后，将该key与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，这样则可以应对短时间的大量的该key攻击，设置为较短的失效时间是因为该值可能业务无关，存在意义不大，且该次的查询也未必是攻击者发起，无过久存储的必要，故可以早点失效。

# 缓存雪崩
在普通的缓存系统中一般例如redis、memcache等中，我们会给缓存设置一个失效时间，但是如果所有的缓存的失效时间相同，那么在同一时间失效时，所有系统的请求都会发送到数据库层，db可能无法承受如此大的压力导致系统崩溃。