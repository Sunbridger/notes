# 什么场景下会发生服务器主动关闭连接？

服务器关机、重启、进程关闭、重启
>释放连接、关闭连接、其实是一回事。采用的手段是发送“FIN”状态位，这个动作在中文的翻译里，经常会翻译成“挥手”。这个场景就是服务器迫于关机指令，主动发起的挥手动作。
所谓优雅，就是看起来不是那么突然，有绅士风度，给客户端足够的响应时间发出自己的挥手动作“FIN”。由于服务器主动发起关闭连接，客户端无需等待就进入“Closed”状态，客户端释放内存与使用的端口。

 
按照TCP状态机流程图，谁主动关闭TCP连接，谁需要等待2倍的 MSL（Maximum Segment Life ）时间，这个等待时间对应的状态为“Time_Wait”。操作系统的MSL时间从30-120秒不等，那么等待时间也不过60-240秒，这点等待时间还算能够忍受。


# 缓存穿透
缓存穿透是指查询一个一定不存在的数据，因为缓存中也无该数据的信息，则会直接去数据库层进行查询，从系统层面来看像是穿透了缓存层直接达到db，从而称为缓存穿透，没有了缓存层的保护，这种查询一定不存在的数据对系统来说可能是一种危险，如果有人恶意用这种一定不存在的数据来频繁请求系统，不，准确的说是攻击系统，请求都会到达数据库层导致db瘫痪从而引起系统故障。


1. bloom filter：类似于哈希表的一种算法，用所有可能的查询条件生成一个bitmap，在进行数据库查询之前会使用这个bitmap进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。guava中有实现BloomFilter算法。


2. 空值缓存：一种比较简单的解决办法，在第一次查询完不存在的数据后，将该key与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，这样则可以应对短时间的大量的该key攻击，设置为较短的失效时间是因为该值可能业务无关，存在意义不大，且该次的查询也未必是攻击者发起，无过久存储的必要，故可以早点失效。

# 缓存雪崩
在普通的缓存系统中一般例如redis、memcache等中，我们会给缓存设置一个失效时间，但是如果所有的缓存的失效时间相同，那么在同一时间失效时，所有系统的请求都会发送到数据库层，db可能无法承受如此大的压力导致系统崩溃。


1. 线程互斥：只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据才可以，每个时刻只有一个线程在执行请求，减轻了db的压力，但缺点也很明显，降低了系统的qps(一句话来说就是对应querys/sec，即针对查询，每秒的响应请求数，也即是最大吞吐能力)。


2. 交错失效时间：这种方法时间比较简单粗暴，既然在同一时间失效会造成请求过多雪崩，那我们错开不同的失效时间即可从一定长度上避免这种问题，在缓存进行失效时间设置的时候，从某个适当的值域中随机一个时间作为失效时间即可。

# WebSocket握手

WebSocket 的 RFC6455 标准中制定了 2 个高级组件，一个是开放性 HTTP 握手用于协商连接参数，另一个是二进制消息分帧机制用于支持低开销的基于消息的文本和二进制数据传输。接下来就好好谈谈这两个高级组件，这一章节详细的谈谈握手的细节，下一个章节再谈谈二进制消息分帧机制。

首先，在 RFC6455 中写了这样一段话：

>WebSocket 协议尝试在既有 HTTP 基础设施中实现双向 HTTP 通信，因此 也使用 HTTP 的 80 和 443 端口......不过，这个设计不限于通过 HTTP 实现 WebSocket 通信，未来的实现可以在某个专用端口上使用更简单的握手，而 不必重新定义么一个协议。 


从这段话中我们可看出制定 WebSocket 协议的人的“野心”或者说对未来的规划有多远，WebSocket 制定之初就已经支持了可以在任意端口上进行握手，而不仅仅是要依靠 HTTP 握手。


不过目前用的对多的还是依靠 HTTP 进行握手。因为 HTTP 的基础设施已经相当完善了。


# :root
:root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同。
在声明全局 CSS 变量时 :root 会很有用：
```
:root {
  --main-color: hotpink;
  --pane-padding: 5px 42px;
}
```



>对font-size使用rem，对border使用px，对其他的度量方式如padding、margin、border-radius等使用em。

# px em rem
px 是绝对的（也就是说，5px在不同的场景下是一样的值）
em rem是相对的（基准值是font-size 不过谁的字号不一样 em是当前的元素字号大小 rem是根的字号大小）

>CSS是通过迟绑定（late-binding）的方式把样式渲染到web页面上的：内容和它的样式会在各自的渲染完成之后再合并到一起。


### em
```
:root {                    
  font-size: 1em;          
}
```

:root 表示html这个元素了
1em:根元素的1em等于浏览器的默认字号大小(16px);
```
body {
  font-size: 16px;
}

.slogan {
  font-size: 1.2em;             1.2*16 = 19.2 px
  padding: 1.2em;               19.2*1.2 = 23.04 px 
  background-color: #ccc;
}
```

缺点：
当你使用em声明多层嵌套的元素字号时，会产生意想不到的效果。要弄清楚每个元素的实际值，首先你需要知道它继承的父元素的字号大小，如果父元素的字号也是用em声明的，那么你需要知道它的父元素的字号大小，在dom树往上查，以此类推。

### rem
rem是根em（root em）的缩写。rem是和根元素关联的，不依赖当前元素。不管你在文档中的什么地方使用这个单位，1.2rem的计算值是相等的，等于1.2倍的根元素（:root 就是这个html元素）的字号大小


# 视口相关单位（viewport-relative units）
已经学完em和rem了，它们都是以font-size为基准值的，但相对单位不只它们。还有视口相关单位，依赖浏览器的视口大小来定义长度的。


视口（viewport） —— 在浏览器窗口中用来`渲染页面的可视区域`，这不包括浏览器的`地址栏`、`工具栏`、`状态栏`等（如果有的话）。
如果你不熟悉视口相关单位的话，在这里简单介绍一下。

vh —— 视口高度的1/100
vw —— 视口宽度的1/100

## 在font-size上使用vw
一个应用如果使用了视口相关单位，可能效果最不明显的地方就是用在字号大小上。事实上，我发现把vh和vw用在字号上比元素的宽或者高更实用。

试想一下，如果把元素的font-size声明为2vm，会怎么样？台式机屏幕宽是1200px，2vm等于24px（1200 * 2%）。而平板电脑的屏幕宽768px，2vm约等于15px（768 * 2%）。很棒的是，元素在两个尺寸下缩放自如。这意味着这里并没有一个突然的断点，元素会随着视口尺寸的增大而平滑增大。

不幸的是，24px对于大屏幕来说有点太大了。而更糟糕的是，在iPhone6(350*2)它直接缩小到7.5px。好消息是缩放生效了，而坏消息是极限情况的处理有点差。你可以通过CSS的方法calc()解决这个问题。


# Android Webview H5交互之LocalStorage
第一步、与H5开发者沟通
首先你需要和H5开发者协商好采用LocalStorage来交互数据，并约定好各数据的key值。



第二步、配置Webview
Android Webview 默认状态下是不支持LocalStorage的，我们要进行以下设置：

```
WebSettings websettings = webView.getSettings();
websettings.setDomStorageEnabled(true);  // 开启 DOM storage 功能
websettings.setAppCacheMaxSize(1024*1024*8);
String appCachePath = context.getApplicationContext().getCacheDir().getAbsolutePath();
websettings.setAppCachePath(appCachePath);
websettings.setAllowFileAccess(true);    // 可以读取文件缓存
websettings.setAppCacheEnabled(true);    //开启H5(APPCache)缓存功能
```
第三步、写入数据
```
webView.setWebViewClient(
                new WebViewClient() {
                    @Override
                    public void onPageFinished(WebView view, String url) {
                        super.onPageFinished(view, url);
                        writeData();
                    }
        );
 public void writeData(){
        String key = "token";
        String val = SpfsUtils.readString(MyApp.getContext(),"token");
        String key2 = "is_app";
        String val2 = "101";
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
            webView.evaluateJavascript("window.localStorage.setItem('"+ key +"','"+ val +"');", null);
            webView.evaluateJavascript("window.localStorage.setItem('"+ key2 +"','"+ val2 +"');", null);
        } else {
            webView.loadUrl("javascript:localStorage.setItem('"+ key +"','"+ val +"');");
            webView.loadUrl("javascript:localStorage.setItem('"+ key2 +"','"+ val2 +"');");
        }
    }

```
>注意：一定要在onPageFinished方法中写入才有效。
就这样就实现了使用LocalStorage 让app与H5共享数据的功能。


# Mysql分表和分区的区别、分库分表介绍与区别

1. 分表，从表面意思上看呢，就是把一张表分成N多个小表。
>每一个小表都是完正的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。


2. 分区，分区呢就是把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上。



`tips:`分表后数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。分区则不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表还是一张表，数据处理还是由自己来完成。



# MySQL索引原理

### 索引目的
索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？

### 索引原理
除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

### 磁盘IO与预读
前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，`不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内`，因为`局部预读性原理`告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。`每一次IO读取的数据我们称之为一页`(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们`读取一页`内的数据时候，实际上才`发生了一次IO`，这个理论对于索引的数据结构设计非常有帮助。


# WebKit
WebKit是一种用来让网页浏览器绘制网页的排版引擎。它被用于Apple Safari。其分支Blink被用于基于Chromium的网页浏览器，如：Opera与Google Chrome。