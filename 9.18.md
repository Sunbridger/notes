# 什么场景下会发生服务器主动关闭连接？

服务器关机、重启、进程关闭、重启
>释放连接、关闭连接、其实是一回事。采用的手段是发送“FIN”状态位，这个动作在中文的翻译里，经常会翻译成“挥手”。这个场景就是服务器迫于关机指令，主动发起的挥手动作。
所谓优雅，就是看起来不是那么突然，有绅士风度，给客户端足够的响应时间发出自己的挥手动作“FIN”。由于服务器主动发起关闭连接，客户端无需等待就进入“Closed”状态，客户端释放内存与使用的端口。

 
按照TCP状态机流程图，谁主动关闭TCP连接，谁需要等待2倍的 MSL（Maximum Segment Life ）时间，这个等待时间对应的状态为“Time_Wait”。操作系统的MSL时间从30-120秒不等，那么等待时间也不过60-240秒，这点等待时间还算能够忍受。


# 缓存穿透
缓存穿透是指查询一个一定不存在的数据，因为缓存中也无该数据的信息，则会直接去数据库层进行查询，从系统层面来看像是穿透了缓存层直接达到db，从而称为缓存穿透，没有了缓存层的保护，这种查询一定不存在的数据对系统来说可能是一种危险，如果有人恶意用这种一定不存在的数据来频繁请求系统，不，准确的说是攻击系统，请求都会到达数据库层导致db瘫痪从而引起系统故障。


1. bloom filter：类似于哈希表的一种算法，用所有可能的查询条件生成一个bitmap，在进行数据库查询之前会使用这个bitmap进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。guava中有实现BloomFilter算法。


2. 空值缓存：一种比较简单的解决办法，在第一次查询完不存在的数据后，将该key与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，这样则可以应对短时间的大量的该key攻击，设置为较短的失效时间是因为该值可能业务无关，存在意义不大，且该次的查询也未必是攻击者发起，无过久存储的必要，故可以早点失效。

# 缓存雪崩
在普通的缓存系统中一般例如redis、memcache等中，我们会给缓存设置一个失效时间，但是如果所有的缓存的失效时间相同，那么在同一时间失效时，所有系统的请求都会发送到数据库层，db可能无法承受如此大的压力导致系统崩溃。


1. 线程互斥：只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据才可以，每个时刻只有一个线程在执行请求，减轻了db的压力，但缺点也很明显，降低了系统的qps(一句话来说就是对应querys/sec，即针对查询，每秒的响应请求数，也即是最大吞吐能力)。


2. 交错失效时间：这种方法时间比较简单粗暴，既然在同一时间失效会造成请求过多雪崩，那我们错开不同的失效时间即可从一定长度上避免这种问题，在缓存进行失效时间设置的时候，从某个适当的值域中随机一个时间作为失效时间即可。

# WebSocket握手

WebSocket 的 RFC6455 标准中制定了 2 个高级组件，一个是开放性 HTTP 握手用于协商连接参数，另一个是二进制消息分帧机制用于支持低开销的基于消息的文本和二进制数据传输。接下来就好好谈谈这两个高级组件，这一章节详细的谈谈握手的细节，下一个章节再谈谈二进制消息分帧机制。

首先，在 RFC6455 中写了这样一段话：

>WebSocket 协议尝试在既有 HTTP 基础设施中实现双向 HTTP 通信，因此 也使用 HTTP 的 80 和 443 端口......不过，这个设计不限于通过 HTTP 实现 WebSocket 通信，未来的实现可以在某个专用端口上使用更简单的握手，而 不必重新定义么一个协议。 


从这段话中我们可看出制定 WebSocket 协议的人的“野心”或者说对未来的规划有多远，WebSocket 制定之初就已经支持了可以在任意端口上进行握手，而不仅仅是要依靠 HTTP 握手。


不过目前用的对多的还是依靠 HTTP 进行握手。因为 HTTP 的基础设施已经相当完善了。


# :root
:root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同。
在声明全局 CSS 变量时 :root 会很有用：
```
:root {
  --main-color: hotpink;
  --pane-padding: 5px 42px;
}
```



>对font-size使用rem，对border使用px，对其他的度量方式如padding、margin、border-radius等使用em。

# px em rem
px 是绝对的（也就是说，5px在不同的场景下是一样的值）
em rem是相对的（基准值是当前元素的字号大小）

>CSS是通过迟绑定（late-binding）的方式把样式渲染到web页面上的：内容和它的样式会在各自的渲染完成之后再合并到一起。


### em
```
:root {                    
  font-size: 1em;          
}
```

:root 表示html这个元素了
1em:根元素的1em等于浏览器的默认字号大小(16px);
```
body {
  font-size: 16px;
}

.slogan {
  font-size: 1.2em;             1.2*16 = 19.2 px
  padding: 1.2em;               19.2*1.2 = 23.04 px 
  background-color: #ccc;
}
```

缺点：
当你使用em声明多层嵌套的元素字号时，会产生意想不到的效果。要弄清楚每个元素的实际值，首先你需要知道它继承的父元素的字号大小，如果父元素的字号也是用em声明的，那么你需要知道它的父元素的字号大小，在dom树往上查，以此类推。

### rem
rem是根em（root em）的缩写。rem是和根元素关联的，不依赖当前元素。不管你在文档中的什么地方使用这个单位，1.2rem的计算值是相等的，等于1.2倍的根元素（:root 就是这个html元素）的字号大小