# webpack 应用编译优化之路
现在越来越多的项目都使用 ES2015+ 开发，并且搭配 webpack + babel 作为工程化基础，并通过 NPM 去加载第三方依赖库。同时为了达到代码复用的目的，我们会把一些自己开发的组件库或者是 JSSDK 抽成独立的仓库维护，并通过 NPM 去加载。

大部分人已经习惯了这样的开发方式，并且觉得非常方便实用。但在方便的背后，却隐藏了两个问题：

- 代码冗余

    一般来说，这些 NPM 包也是基于 ES2015+ 开发的，每个包都需要经过 babel 编译发布后才能被主应用使用，而这个编译过程往往会附加很多“编译代码”；每个包都会有一些相同的编译代码，这就造成大量代码的冗余，并且这部分冗余代码是不能通过 Tree Shaking 等技术去除掉的。
- 非必要的依赖

    考虑到组件库的场景，通常我们为了方便一股脑引入了所有组件；但实际情况下对于一个应用而言可能只是用到了部分组件，此时如果全部引入，也会造成代码冗余。

## 解决方式

我们对于上述的 2 个问题，核心的解决优化方案是：`后编译` 和 `按需引入`。

### 后编译
>后编译：指的是应用依赖的 NPM 包并不需要在发布前编译，而是随着应用编译打包的时候一块编译。

后编译的核心在于把编译依赖包的时机延后，并且统一编译；先来看看它的 webpack 配置。

```
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.js$/,
        loader: 'babel-loader',
        // 注意这里的 include
        // 除了 src 还包含了额外的 node_modules 下的两个包
        include: [
		    resolve('src'),
		    resolve('node_modules/A'),
		    resolve('node_modules/B')
		  ]
      },
      // ...
    ]
  },
  /
  ```

我们只需要把后编译的模块 A 和 B 通过 webpack 的 include 配置包含进来即可。

### 按需引入

>为了解决这个问题，我们需要按需引入。目前主流组件库或者工具包也都是提供按需引入能力的，但是基本都是提供对编译后模块引入。而我们推荐的是对源码的按需引入，配合后编译的打包方案 。
