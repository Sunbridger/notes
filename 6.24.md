## UMD
UMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。 许多流行的库，比如 Moment.js，就是这样的形式。 比如，在Node.js或RequireJS里，你可以这样写：

```
import moment = require("moment");
console.log(moment.format());
```
然而在纯净的浏览器环境里你也可以这样写：
```
console.log(moment.format());
```

## 识别UMD库
UMD模块会检查是否存在模块加载器环境。 这是非常形容观察到的模块，它们会像下面这样：
```
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define(["libName"], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory(require("libName"));
    } else {
        root.returnExports = factory(root.libName);
    }
}(this, function (b) {
```
如果你在库的源码里看到了typeof define，typeof window，或typeof module这样的测试，尤其是在文件的顶端，那么它几乎就是一个UMD库。

## 类型通过以下方式引入：
+ 类型别名声明（type sn = number | string;）
+ 接口声明（interface I { x: number[]; }）
+ 类声明（class C { }）
+ 枚举声明（enum E { A, B, C }）
+ 指向某个类型的import声明
### 以上每种声明形式都会创建一个新的类型名称。

#### class C { }声明创建了两个东西： 
+ 类型C指向类的实例结构
+ 值C指向类构造函数。

### 我们可以使用一个interface往别一个interface声明里添加额外成员：

```
interface Foo {
  x: number;
}
// ... elsewhere ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
```
这同样作用于类：
```
class Foo {
  x: number;
}
// ... elsewhere ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
```

