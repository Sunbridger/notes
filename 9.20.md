# 前端异常捕获

可以捕获JavaScript错误的基本方法有以下三个：

1. try…catch
2. window.onerror
3. 利用Promise.prototype.catch()


评价捕获错误方式的好坏可以从以下几个维度考虑：
```
1. 错误信息的完整性和可读性，包括完整的错误堆栈（Error Stack）
2. 是否可以捕获异步错误
3. 是否可以捕获跨域脚本的错误
4. 对源代码的破坏性
```




<hr>

1. try...catch**优点**是可以`返回完整的错误堆栈`，**缺点**是`无法捕获异步异常`并且`会修改源代码`

2. window.onerror的**优点**`可以捕获同步和异步的异常`,**缺点**是`不能捕获跨域脚本的错误`
>tips:可以通过修改一些参数使其缺点去掉哦
`可以通过在<script>中设置crossorigin为anonymous来解决，同时服务器端也要做出修改，设置responese headers Access-Control-Allow-Origin:*`

3. Promise.prototype.catch的**优点**可以`捕获Promise实例中发生的异常`。**缺点**是`只能捕获promise内部的错误`。
```
//由于queryData()返回的是一个promise实例，所以可以用catch对异常进行捕获
queryData().catch(error => {
  console.log(error)
})
```




# 其他捕获异常方式
框架提供的处理方式：
1. Vue提供的错误处理回调——Vue.errorHandler(无法捕获异步异常）
2. 微信小程序提供的错误处理——onError(异步、同步都可以捕获)。
3. 第三方错误监控解决方案——sentry和bugsnag
4. hack手法——利用babel，将源码解析成功AST语法树，然后在所有function追加try…catch，重写js原生方法如setTimeout、forEach等方法.（这样代码体积会膨胀）



# 经常出现的错误信息
<font color=red size=14>Uncaught TypeError: Cannot read property 'xxx' of undefined</font>
原因：

1. vue或者react或者ag中没有初始化state数据（真实数据为接口返回）
2. res.likes.map()  // res.likes 是个undefined


<font color=red size=14>(unknown): Script error</font>
原因：

1. 当一个未捕获的 JavaScript 错误违反了跨域策略时，就会出现这类脚本错误


<font color=red size=14>Uncaught RangeError: Maximum call stack</font>
原因：

1. 调用一个不终止的递归函数时发生

